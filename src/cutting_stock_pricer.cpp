#include "../include/scip_pricer.hpp"
#include <iostream>

/* ===================================================================
   IMPLEMENTATION NOTES:
   
   Key SCIP concepts used here:
   1. SCIPincludePricer() - registers pricer with SCIP
   2. SCIPaddPricedVar() - adds column generated by pricer
   3. SCIPgetDualsolLinear() - gets dual values for pricing
   4. SCIPcreateVarBasic() - creates new variables
   
   Memory management:
   - SCIP owns constraints and variables after SCIPaddCons/SCIPaddVar
   - We must release local references with SCIPreleaseCons/SCIPreleaseVar
   - PricerData is owned by this class, freed in scipFree()
   =================================================================== */

/* -------------------------------------------------------------------
   CUTTING STOCK PRICER IMPLEMENTATION
   This does 3 main things:
   1. Creates problem data structure
   2. Registers pricer with SCIP using SCIPincludePricer()
   3. Sets up the manager bridge
------------------------------------------------------------------- */
CuttingStockPricer::CuttingStockPricer(ScipSolver& solver,
                                      const std::vector<int>& widths,
                                      int rollWidth)
    : BasePricer(solver.get(), "dp_pricer"), data_(nullptr) {
    
    // Create pricer data. This will be passed to SCIP as void* user data
    data_ = new PricerData(widths, rollWidth);
    
    // Register pricer in SCIP
    // SCIPincludePricer() tells SCIP about our pricer and its callbacks
    SCIP_CALL_EXCEPT(SCIPincludePricer(
        scip_, "dp_pricer", "DP Knapsack Pricer", 
        0,                    // priority, 0=default
        TRUE,                 // delay pricing
        nullptr,              // pricerCopy
        BasePricer::scipFreeCallback,
        BasePricer::scipInitCallback,
        nullptr,              // pricerExit (optional)
        nullptr,              // pricerInitsol (optional)
        nullptr,              // pricerExitsol (optional)
        BasePricer::scipRedcostCallback, // Pricing callback (static)
        BasePricer::scipFarkasCallback, // Farkas pricing (static)
        (SCIP_PRICERDATA*)data_  // User data passed to callbacks
    ));
    
    // Find and store the pricer
    scipPricer_ = SCIPfindPricer(scip_, "dp_pricer");
    if (scipPricer_ == nullptr) {
        throw std::runtime_error("Failed to find pricer after inclusion");
    }
    
    // Register with manager (bridges C pointer to C++ object)
    ScipPricerManager::getInstance().registerPricer(scipPricer_, this);
    
    // Activate pricer (tells SCIP to use it)
    SCIP_CALL_EXCEPT(SCIPactivatePricer(scip_, scipPricer_));
}

CuttingStockPricer::~CuttingStockPricer() {
    // Data is freed in scipFree callback
}

/* -------------------------------------------------------------------
   SET DEMAND CONSTRAINTS
   
   Called by SimpleCuttingStockSolver after creating constraints.
   Stores constraint pointers for later dual value access.
------------------------------------------------------------------- */
void CuttingStockPricer::setDemandConstraints(const std::vector<SCIP_CONS*>& cons) {
    data_->demandConss = cons;
}

SCIP_RETCODE CuttingStockPricer::scipFree(SCIP* scip, SCIP_PRICER* pricer) {
    if (data_ != nullptr) {
        delete data_;
        data_ = nullptr;
        SCIPpricerSetData(pricer, nullptr);
    }
    return SCIP_OKAY;
}

SCIP_RETCODE CuttingStockPricer::scipInit(SCIP* scip, SCIP_PRICER* pricer) {
    // Transform constraints (like original code)
    for (size_t i = 0; i < data_->demandConss.size(); ++i) {
        SCIP_CONS* trans = nullptr;
        SCIP_CALL(SCIPgetTransformedCons(scip, data_->demandConss[i], &trans));
        data_->demandConss[i] = trans;
    }
    return SCIP_OKAY;
}

std::vector<double> CuttingStockPricer::getDuals(SCIP* scip) const {
    int n = data_->widths.size();
    std::vector<double> duals(n);
    for (int i = 0; i < n; ++i) {
        duals[i] = SCIPgetDualsolLinear(scip, data_->demandConss[i]);
    }
    return duals;
}

double CuttingStockPricer::solveKnapsack(const std::vector<double>& duals,
                                        std::vector<int>& pattern) const {
    int n = data_->widths.size();
    int W = data_->rollWidth;
    
    // DP for unbounded knapsack
    std::vector<double> dp(W + 1, 0.0);
    std::vector<int> keepTrack(W + 1, -1);
    
    for (int w = 0; w <= W; ++w) {
        for (int i = 0; i < n; ++i) {
            if (data_->widths[i] <= w) {
                if (dp[w - data_->widths[i]] + duals[i] > dp[w]) {
                    dp[w] = dp[w - data_->widths[i]] + duals[i];
                    keepTrack[w] = i;
                }
            }
        }
    }
    
    double bestValue = dp[W];
    
    // Reconstruct pattern
    pattern.assign(n, 0);
    int w = W;
    while (w > 0 && keepTrack[w] != -1) {
        int itemIdx = keepTrack[w];
        pattern[itemIdx]++;
        w -= data_->widths[itemIdx];
    }
    
    return bestValue;
}

SCIP_RETCODE CuttingStockPricer::scipRedcost(SCIP* scip, SCIP_PRICER* pricer,
                                            double* lowerbound,
                                            unsigned int* naddedvars,
                                            SCIP_Result* result) {
    // SCIP 10: Initialize counters
    unsigned int addedVars = 0;
    if (naddedvars != nullptr) {
        *naddedvars = 0;  // Initialize to 0
    }
    
    // Crucial: Always set result to SUCCESS
    *result = SCIP_SUCCESS;
    
    // Get duals
    auto duals = getDuals(scip);
    
    // Solve knapsack
    std::vector<int> pattern;
    double bestValue = solveKnapsack(duals, pattern);
    
    std::cout << "Pricer called. Best value: " << bestValue 
              << " (need > 1.0)" << std::endl;
    
    // If reduced cost is negative (value > 1.0), add pattern
    if (bestValue > 1.0 + 1e-6) {
        int n = data_->widths.size();
        
        // Create and add the priced variable
        SCIP_VAR* var = nullptr;
        std::string name = "pat_" + std::to_string(SCIPgetNLPCols(scip));
        SCIP_CALL(SCIPcreateVarBasic(scip, &var, name.c_str(), 
            0.0, SCIPinfinity(scip), 1.0, SCIP_VARTYPE_INTEGER));
        
        SCIP_CALL(SCIPvarSetInitial(var, TRUE));
        SCIP_CALL(SCIPvarSetRemovable(var, TRUE));
        SCIP_CALL(SCIPaddPricedVar(scip, var, 1.0));
        
        for (int i = 0; i < n; ++i) {
            if (pattern[i] > 0) {
                SCIP_CALL(SCIPaddCoefLinear(scip, data_->demandConss[i], var, 
                    (SCIP_Real)pattern[i]));
            }
        }
        
        std::cout << "Added pattern: [";
        for (int i = 0; i < n; ++i) {
            if (pattern[i] > 0) std::cout << pattern[i] << "*" << i << " ";
        }
        std::cout << "], value=" << bestValue << std::endl;
        
        SCIP_CALL(SCIPreleaseVar(scip, &var));
        
        // SCIP 10: Increment counter
        addedVars = 1;  // We added one variable
    } else {
        std::cout << "No improving pattern found" << std::endl;
    }
    
    // SCIP 10: Set output parameters
    if (naddedvars != nullptr) {
        *naddedvars = addedVars;
    }
    
    return SCIP_OKAY;
}

/* -------------------------------------------------------------------
   SIMPLE CUTTING STOCK SOLVER IMPLEMENTATION
------------------------------------------------------------------- */
SimpleCuttingStockSolver::SimpleCuttingStockSolver(
    const std::vector<int>& widths,
    const std::vector<int>& demands,
    int rollWidth)
    : widths_(widths), demands_(demands), rollWidth_(rollWidth) {
    
    // Create solver
    solver_ = std::make_unique<ScipSolver>("cutting_stock_dp");
    solver_->setMinimize();
    
    // Create pricer
    pricer_ = std::make_unique<CuttingStockPricer>(*solver_, widths, rollWidth);
}

double SimpleCuttingStockSolver::solve() {
    SCIP* scip = solver_->get();
    
    // 1. Create constraints (matches original)
    std::vector<SCIP_CONS*> conss;
    for (size_t i = 0; i < widths_.size(); ++i) {
        SCIP_CONS* cons;
        SCIP_CALL_EXCEPT(SCIPcreateConsBasicLinear(
            scip, &cons, "d", 
            0, nullptr, nullptr, 
            (double)demands_[i], 
            SCIPinfinity(scip)));
        
        SCIP_CALL_EXCEPT(SCIPsetConsModifiable(scip, cons, TRUE));
        SCIP_CALL_EXCEPT(SCIPaddCons(scip, cons));
        conss.push_back(cons);
    }
    
    pricer_->setDemandConstraints(conss);
    
    // 2. Initial columns (one roll per item)
    for (size_t i = 0; i < widths_.size(); ++i) {
        SCIP_VAR* var;
        SCIP_CALL_EXCEPT(SCIPcreateVarBasic(
            scip, &var, "init", 
            0.0, SCIPinfinity(scip), 
            1.0, SCIP_VARTYPE_CONTINUOUS));
        
        SCIP_CALL_EXCEPT(SCIPaddVar(scip, var));
        SCIP_CALL_EXCEPT(SCIPaddCoefLinear(scip, conss[i], var, 1.0));
        
        // Release variable (SCIP keeps ownership)
        SCIP_CALL_EXCEPT(SCIPreleaseVar(scip, &var));
    }
    
    // 3. Solve (SCIP will automatically call pricer)
    std::cout << "\nSolving with SCIP (column generation will run automatically)..." << std::endl;
    solver_->solve();
    
    // 4. Cleanup constraints
    for (auto cons : conss) {
        SCIP_CALL_EXCEPT(SCIPreleaseCons(scip, &cons));
    }
    
    return solver_->getObjectiveValue();
}

void SimpleCuttingStockSolver::printSolution() const {
    std::cout << "\n=== Final Solution ===" << std::endl;
    std::cout << "Total rolls: " << solver_->getObjectiveValue() << std::endl;
    
    // Calculate lower bound
    double totalWidth = 0;
    for (size_t i = 0; i < widths_.size(); ++i) {
        totalWidth += widths_[i] * demands_[i];
    }
    double lowerBound = totalWidth / rollWidth_;
    
    std::cout << "Theoretical lower bound: " << lowerBound << std::endl;
    std::cout << "Gap: " << solver_->getObjectiveValue() - lowerBound << std::endl;
}